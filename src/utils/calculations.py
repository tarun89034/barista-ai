import numpy as np\nimport pandas as pd\nimport scipy.stats as stats\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef calculate_variance(price_series: pd.Series) -> float:\n    return np.var(price_series)\n\ndef calculate_volatility(price_series: pd.Series) -> float:\n    return np.std(price_series)\n\ndef calculate_var(price_series: pd.Series, confidence_level: float = 0.95, method: str = 'parametric') -> float:\n    if method == 'parametric':\n        mean = np.mean(price_series)\n        sigma = calculate_volatility(price_series)\n        var = mean - sigma * stats.norm.ppf(confidence_level)\n        return var\n    elif method == 'historical':\n        return np.percentile(price_series, (1 - confidence_level) * 100)\n    elif method == 'monte_carlo':\n        simulations = np.random.normal(np.mean(price_series), np.std(price_series), 10000)\n        return np.percentile(simulations, (1 - confidence_level) * 100)\n    else:\n        logging.error('Invalid method for VaR calculation. Choose from parametric, historical, or Monte Carlo.')\n        return np.nan\n\ndef calculate_cvar(price_series: pd.Series, confidence_level: float = 0.95) -> float:\n    var = calculate_var(price_series, confidence_level=confidence_level)\n    cvar = price_series[price_series <= var].mean()\n    return cvar\n\ndef calculate_sharpe_ratio(price_series: pd.Series, risk_free_rate: float = 0.01) -> float:\n    avg_return = np.mean(price_series) - risk_free_rate\n    volatility = calculate_volatility(price_series)\n    if volatility == 0: return np.nan\n    return avg_return / volatility\n\ndef calculate_beta(asset_returns: pd.Series, market_returns: pd.Series) -> float:\n    covariance = np.cov(asset_returns, market_returns)[0][1]\n    market_variance = calculate_variance(market_returns)\n    if market_variance == 0: return np.nan\n    return covariance / market_variance\n\ndef calculate_sortino_ratio(price_series: pd.Series, target_return: float = 0) -> float:\n    downside_returns = price_series[price_series < target_return]\n    expected_downside_return = np.mean(downside_returns)\n    if expected_downside_return == 0: return np.nan\n    return (np.mean(price_series) - target_return) / np.std(downside_returns)\n\ndef calculate_information_ratio(price_series: pd.Series, benchmark_series: pd.Series) -> float:\n    active_return = price_series - benchmark_series\n    return np.mean(active_return) / np.std(active_return)\n\ndef calculate_treynor_ratio(price_series: pd.Series, benchmark_returns: pd.Series, risk_free_rate: float = 0.01) -> float:\n    return (np.mean(price_series) - risk_free_rate) / calculate_beta(price_series, benchmark_returns)\n\ndef calculate_calmar_ratio(price_series: pd.Series) -> float:\n    max_drawdown = calculate_max_drawdown(price_series)\n    annual_return = np.mean(price_series)\n    if max_drawdown == 0: return np.nan\n    return annual_return / max_drawdown\n\ndef calculate_max_drawdown(price_series: pd.Series) -> float:\n    peak = price_series[0]\n    max_dd = 0\n    for price in price_series:\n        if price > peak:\n            peak = price\n        drawdown = (peak - price) / peak\n        max_dd = max(max_dd, drawdown)\n    return max_dd\n\ndef calculate_correlation_matrix(data: pd.DataFrame) -> pd.DataFrame:\n    return data.corr()\n\ndef portfolio_metrics(returns: pd.Series) -> dict:\n    metrics = {\n        'Volatility': calculate_volatility(returns),\n        'VaR (95%)': calculate_var(returns),\n        'CVaR (95%)': calculate_cvar(returns),\n        'Sharpe Ratio': calculate_sharpe_ratio(returns),\n        'Beta': calculate_beta(returns, returns.mean()),\n        'Sortino Ratio': calculate_sortino_ratio(returns)\n    }\n    return metrics\n\n# Example log\nlogging.info("Financial calculations module loaded successfully.")\n